from aiogram import Router, F
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from aiogram.filters import Command
from handlers.keyboards import get_main_menu
import sys
import os
import random
import string
import sqlite3

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database import (
    create_user,
    get_user,
    set_user_level,
    mark_onboarding_completed,
    is_onboarding_completed,
    DB_NAME,
)
from logger import get_logger

router = Router()
logger = get_logger("onboarding")

# –û–ø–∏—Å–∞–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π
LEVEL_DESCRIPTIONS = {
    "A1": "–ù–∞—á–∏–Ω–∞—é—â–∏–π - –∑–Ω–∞—é –∞–ª—Ñ–∞–≤–∏—Ç, –ø—Ä–æ—Å—Ç—ã–µ —Ñ—Ä–∞–∑—ã (Hello, Thank you)",
    "A2": "–≠–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π - –º–æ–≥—É –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å—Å—è, —Ä–∞—Å—Å–∫–∞–∑–∞—Ç—å –æ —Å–µ–±–µ",
    "B1": "–°—Ä–µ–¥–Ω–∏–π - –º–æ–≥—É –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –±–µ—Å–µ–¥—É –Ω–∞ –∑–Ω–∞–∫–æ–º—ã–µ —Ç–µ–º—ã",
    "B2": "–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π - —Å–≤–æ–±–æ–¥–Ω–æ –æ–±—â–∞—é—Å—å, –ø–æ–Ω–∏–º–∞—é —Ñ–∏–ª—å–º—ã",
}

# –ü—Ä–æ–≤–µ—Ä–æ—á–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
VERIFICATION_QUESTIONS = {
    "A1": [
        {
            "question": "How do you say '–ü—Ä–∏–≤–µ—Ç' in English?",
            "options": ["Hello", "Goodbye", "Please", "Sorry"],
            "correct": 0,
        },
        {
            "question": "What is this: üçé?",
            "options": ["Banana", "Apple", "Orange", "Grape"],
            "correct": 1,
        },
        {
            "question": "Choose the correct word: I ___ Denis.",
            "options": ["am", "is", "are", "be"],
            "correct": 0,
        },
    ],
    "A2": [
        {
            "question": "I ___ to the cinema yesterday.",
            "options": ["go", "went", "gone", "going"],
            "correct": 1,
        },
        {
            "question": "She ___ like coffee.",
            "options": ["don't", "doesn't", "isn't", "aren't"],
            "correct": 1,
        },
        {
            "question": "Where ___ you live?",
            "options": ["do", "does", "did", "are"],
            "correct": 0,
        },
    ],
    "B1": [
        {
            "question": "If I ___ you, I would take that job.",
            "options": ["am", "was", "were", "be"],
            "correct": 2,
        },
        {
            "question": "I've been ___ for this company for 5 years.",
            "options": ["work", "worked", "working", "works"],
            "correct": 2,
        },
        {
            "question": "I would rather ___ at home tonight.",
            "options": ["stay", "staying", "to stay", "stayed"],
            "correct": 0,
        },
    ],
    "B2": [
        {
            "question": "The project ___ by the end of next month.",
            "options": [
                "will complete",
                "will be completed",
                "completes",
                "is completing",
            ],
            "correct": 1,
        },
        {
            "question": "I wish I ___ more time to study last year.",
            "options": ["have", "had", "had had", "would have"],
            "correct": 2,
        },
        {
            "question": "Hardly ___ finished when the phone rang.",
            "options": ["I had", "had I", "I have", "have I"],
            "correct": 1,
        },
    ],
}


def get_level_selection_keyboard():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ —É—Ä–æ–≤–Ω—è"""
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text=f"üî∞ A1 - {LEVEL_DESCRIPTIONS['A1']}", callback_data="level_A1"
                )
            ],
            [
                InlineKeyboardButton(
                    text=f"üìó A2 - {LEVEL_DESCRIPTIONS['A2']}", callback_data="level_A2"
                )
            ],
            [
                InlineKeyboardButton(
                    text=f"üìò B1 - {LEVEL_DESCRIPTIONS['B1']}", callback_data="level_B1"
                )
            ],
            [
                InlineKeyboardButton(
                    text=f"üìô B2 - {LEVEL_DESCRIPTIONS['B2']}", callback_data="level_B2"
                )
            ],
        ]
    )
    return keyboard


@router.callback_query(F.data == "start_onboarding")
async def start_onboarding(callback: CallbackQuery):
    """–ù–∞—á–∞–ª–æ –æ–Ω–±–æ—Ä–¥–∏–Ω–≥–∞"""
    await callback.answer()

    text = (
        "üéØ –î–û–ë–†–û –ü–û–ñ–ê–õ–û–í–ê–¢–¨ –í ENGLISH TUTOR!\n\n"
        "–î–∞–≤–∞–π –æ–ø—Ä–µ–¥–µ–ª–∏–º —Ç–≤–æ–π —É—Ä–æ–≤–µ–Ω—å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ.\n"
        "–≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –º–Ω–µ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ –ø–æ–¥ —Ç–µ–±—è.\n\n"
        "–í—ã–±–µ—Ä–∏ —Å–≤–æ–π –ø—Ä–∏–º–µ—Ä–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å:"
    )

    await callback.message.answer(text, reply_markup=get_level_selection_keyboard())


@router.callback_query(F.data.startswith("level_"))
async def select_level(callback: CallbackQuery):
    """–í—ã–±–æ—Ä —É—Ä–æ–≤–Ω—è –∏ –Ω–∞—á–∞–ª–æ —Ç–µ—Å—Ç–∞"""
    await callback.answer()

    level = callback.data.split("_")[1]  # A1, A2, B1, B2
    user_id = callback.from_user.id

    questions = VERIFICATION_QUESTIONS[level]
    question_data = questions[0]

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=option, callback_data=f"verify_{level}_0_{i}_0")]
            for i, option in enumerate(question_data["options"])
        ]
    )

    text = (
        f"–û—Ç–ª–∏—á–Ω–æ! –î–∞–≤–∞–π –ø—Ä–æ–≤–µ—Ä–∏–º —É—Ä–æ–≤–µ–Ω—å {level}.\n\n"
        f"–í–æ–ø—Ä–æ—Å 1 –∏–∑ {len(questions)}:\n\n"
        f"{question_data['question']}"
    )

    await callback.message.answer(text, reply_markup=keyboard)


@router.callback_query(F.data.startswith("verify_"))
async def verify_answer(callback: CallbackQuery):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –≤–æ–ø—Ä–æ—Å + –ø—Ä–∞–≤–∏–ª–æ 2/3"""
    await callback.answer()

    parts = callback.data.split("_")
    # verify_{level}_{question_idx}_{answer_idx}_{score}
    level = parts[1]
    question_idx = int(parts[2])
    answer_idx = int(parts[3])
    score = int(parts[4])

    questions = VERIFICATION_QUESTIONS[level]
    current_question = questions[question_idx]

    is_correct = answer_idx == current_question["correct"]
    if is_correct:
        score += 1

    next_idx = question_idx + 1

    # –ï—â—ë –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π
    if next_idx < len(questions):
        next_question = questions[next_idx]

        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text=option,
                        callback_data=f"verify_{level}_{next_idx}_{i}_{score}",
                    )
                ]
                for i, option in enumerate(next_question["options"])
            ]
        )

        feedback = "–ü—Ä–∞–≤–∏–ª—å–Ω–æ! ‚úÖ" if is_correct else "–ù–µ —Å–æ–≤—Å–µ–º ü§î"
        text = (
            f"{feedback}\n\n"
            f"–í–æ–ø—Ä–æ—Å {next_idx + 1} –∏–∑ {len(questions)}:\n\n"
            f"{next_question['question']}"
        )
        await callback.message.answer(text, reply_markup=keyboard)
        return

    # –í–æ–ø—Ä–æ—Å—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å ‚Äî —Ä–µ—à–∞–µ–º –ø–æ –ø—Ä–∞–≤–∏–ª—É 2 –∏–∑ 3
    passed = score >= 2

    if passed:
        await complete_onboarding(callback, level, last_correct=True)
        return

    # ‚ùå –ü—Ä–æ–≤–∞–ª: –ù–ï –∑–∞–≤–µ—Ä—à–∞–µ–º –æ–Ω–±–æ—Ä–¥–∏–Ω–≥. –î–∞–µ–º –≤—ã–±–æ—Ä: –ø—Ä–æ–π—Ç–∏ –∑–∞–Ω–æ–≤–æ –∏–ª–∏ –≤—ã–±—Ä–∞—Ç—å —É—Ä–æ–≤–µ–Ω—å.
    retry_kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="üîÅ –ü—Ä–æ–π—Ç–∏ –≤–æ–ø—Ä–æ—Å—ã –∑–∞–Ω–æ–≤–æ", callback_data=f"retry_{level}"
                )
            ],
            [
                InlineKeyboardButton(
                    text="üîô –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π —É—Ä–æ–≤–µ–Ω—å", callback_data="start_onboarding"
                )
            ],
        ]
    )

    await callback.message.answer(
        f"–ü–æ—Ö–æ–∂–µ, —É—Ä–æ–≤–µ–Ω—å **{level}** –ø–æ–∫–∞ —Å–ª–æ–∂–Ω–æ–≤–∞—Ç üòÖ\n"
        f"–†–µ–∑—É–ª—å—Ç–∞—Ç: **{score} / {len(questions)}**\n\n"
        f"–•–æ—á–µ—à—å –ø—Ä–æ–π—Ç–∏ –≤–æ–ø—Ä–æ—Å—ã –∑–∞–Ω–æ–≤–æ –∏–ª–∏ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π —É—Ä–æ–≤–µ–Ω—å?",
        reply_markup=retry_kb,
        parse_mode="Markdown",
    )


@router.callback_query(F.data.startswith("retry_"))
async def retry_questions(callback: CallbackQuery):
    await callback.answer()
    level = callback.data.split("_")[1]
    questions = VERIFICATION_QUESTIONS[level]
    question_data = questions[0]

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=option, callback_data=f"verify_{level}_0_{i}_0")]
            for i, option in enumerate(question_data["options"])
        ]
    )

    text = (
        f"–û–∫! –ü–æ–≤—Ç–æ—Ä–∏–º –ø—Ä–æ–≤–µ—Ä–∫—É —É—Ä–æ–≤–Ω—è {level}.\n\n"
        f"–í–æ–ø—Ä–æ—Å 1 –∏–∑ {len(questions)}:\n\n"
        f"{question_data['question']}"
    )
    await callback.message.answer(text, reply_markup=keyboard)


def generate_referral_code():
    return "".join(random.choices(string.ascii_uppercase + string.digits, k=6))


async def complete_onboarding(callback: CallbackQuery, level: str, last_correct: bool):
    """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–Ω–±–æ—Ä–¥–∏–Ω–≥–∞ + –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞"""
    user_id = callback.from_user.id
    username = callback.from_user.username

    # –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º
    if not get_user(user_id):
        create_user(user_id, username)

    # –í—Å–µ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ (–¥–∞–∂–µ –µ—Å–ª–∏ –æ–Ω–±–æ—Ä–¥–∏–Ω–≥ —É–∂–µ –ø—Ä–æ–π–¥–µ–Ω)
    user = get_user(user_id)
    if user and len(user) > 8 and not user[8]:  # referral_code –ø—É—Å—Ç–æ–π?
        referral_code = generate_referral_code()
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute(
            "UPDATE users SET referral_code = ? WHERE user_id = ?",
            (referral_code, user_id),
        )
        conn.commit()
        conn.close()
        logger.info(
            f"–†–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {referral_code}"
        )

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —É—Ä–æ–≤–µ–Ω—å
    set_user_level(user_id, level)
    mark_onboarding_completed(user_id)

    # === –ì–ï–ù–ï–†–ò–†–£–ï–ú –ò –°–û–•–†–ê–ù–Ø–ï–ú –†–ï–§–ï–†–ê–õ–¨–ù–´–ô –ö–û–î ===
    referral_code = generate_referral_code()
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(
        "UPDATE users SET referral_code = ? WHERE user_id = ?", (referral_code, user_id)
    )
    conn.commit()
    conn.close()

    logger.info(
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–≤–µ—Ä—à–∏–ª –æ–Ω–±–æ—Ä–¥–∏–Ω–≥, —É—Ä–æ–≤–µ–Ω—å: {level}, —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥: {referral_code}"
    )

    feedback = "–û—Ç–ª–∏—á–Ω–æ! ‚úÖ" if last_correct else "–•–æ—Ä–æ—à–∞—è –ø–æ–ø—ã—Ç–∫–∞! üëç"

    text = (
        f"{feedback}\n\n"
        f"üéâ –û–Ω–±–æ—Ä–¥–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω!\n\n"
        f"–¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: **{level}**\n"
        f"{LEVEL_DESCRIPTIONS[level]}\n\n"
        f"–¢–µ–ø–µ—Ä—å —è –±—É–¥—É –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–∏ –æ—Ç–≤–µ—Ç—ã –ø–æ–¥ —Ç–≤–æ–π —É—Ä–æ–≤–µ–Ω—å.\n\n"
        f"–ù–∞—á–Ω–µ–º –ø—Ä–∞–∫—Ç–∏–∫—É! –û—Ç–ø—Ä–∞–≤—å –≥–æ–ª–æ—Å–æ–≤–æ–µ –∏–ª–∏ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."
    )

    await callback.message.answer(
        text,
        parse_mode="HTML",
        reply_markup=get_main_menu(user_id, username),
    )

    await callback.message.answer(
        "‚úÖ –ú–µ–Ω—é –≤–∫–ª—é—á–µ–Ω–æ",
        reply_markup=get_main_menu(user_id, username),
    )
