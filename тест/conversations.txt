from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, FSInputFile
from aiogram.enums import ChatAction
import sys
import os
import re
import json
import ast
import asyncio
import random
import tempfile
from time import time
from datetime import date, timedelta
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery


sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database import (
    get_conversation_history,
    save_message,
    increment_message_count,
    get_user,
    create_user,
    can_send_message,
    is_onboarding_completed,
    update_user_streak,
    user_get,
    has_active_subscription,
)
from services.ollama_service import get_dynamic_suggestions

from services.ollama_service import get_ollama_response
from services.whisper_service import transcribe_audio
from services.tts_service import text_to_speech
from handlers.keyboards import get_main_menu

from dotenv import load_dotenv

load_dotenv()
WHITELIST_USERNAMES = os.getenv("WHITELIST_USERNAMES", "").split(",")

from logger import get_logger

logger = get_logger("conversation")

router = Router()
_last_message_time = {}
RATE_LIMIT_SECONDS = 3
SUGGESTIONS_CACHE: dict[int, dict[str, str]] = {}


def extract_question_for_suggestions(bot_text: str) -> str:
    """
    –ë–µ—Ä—ë–º –≤–æ–ø—Ä–æ—Å —É—á–∏—Ç–µ–ª—è –∏–∑ –æ—Ç–≤–µ—Ç–∞ –º–æ–¥–µ–ª–∏.
    –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: —Å—Ç—Ä–æ–∫–∞ 'Question: ...'
    –§–æ–ª–±—ç–∫: –ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–æ–∫–∞ —Å '?'
    """
    if not bot_text:
        return ""

    # 1) Question: ...
    for line in bot_text.splitlines():
        if line.strip().lower().startswith("question:"):
            q = line.split(":", 1)[1].strip()
            return q

    # 2) last line with '?'
    lines = [ln.strip() for ln in bot_text.splitlines() if ln.strip()]
    for ln in reversed(lines):
        if "?" in ln:
            return ln

    return ""


# phrases = [p.strip() for p in phrases if isinstance(p, str) and p.strip()]


def normalize_suggestion_phrases(raw) -> list[str]:
    """
    –ü—Ä–∏–≤–æ–¥–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç get_dynamic_suggestions –∫ —Å–ø–∏—Å–∫—É –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–ª—É—á–∞–∏:
    - list[str]
    - JSON —Å—Ç—Ä–æ–∫–∞: ["...","..."]
    - Python-list —Å—Ç—Ä–æ–∫–∞: ['...','...']
    - –û–¥–Ω–∞ –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ (–ø–æ —Å—Ç—Ä–æ–∫–∞–º/–∫–∞–≤—ã—á–∫–∞–º/—Ç–æ—á–∫–∞–º —Å –∑–∞–ø—è—Ç–æ–π)
    """
    if raw is None:
        return []

    phrases = raw

    # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–∞ —Å—Ç—Ä–æ–∫–∞ ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ —Å–ø–∏—Å–æ–∫
    if isinstance(phrases, str):
        s = phrases.strip()

        # JSON / python literal list
        if (s.startswith("[") and s.endswith("]")) or (
            s.startswith("(") and s.endswith(")")
        ):
            # —Å–Ω–∞—á–∞–ª–∞ JSON
            try:
                phrases = json.loads(s)
            except Exception:
                # –∑–∞—Ç–µ–º literal_eval (–ø–æ–¥–¥–µ—Ä–∂–∏—Ç –æ–¥–∏–Ω–∞—Ä–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏)
                try:
                    phrases = ast.literal_eval(s)
                except Exception:
                    phrases = s
        else:
            phrases = s

    # –ï—Å–ª–∏ –ø–æ—Å–ª–µ –ø–∞—Ä—Å–∏–Ω–≥–∞ —ç—Ç–æ –Ω–µ —Å–ø–∏—Å–æ–∫ ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º —Ä–∞–∑—Ä–µ–∑–∞—Ç—å —Å—Ç—Ä–æ–∫—É
    if isinstance(phrases, str):
        s = phrases.strip()

        # –≤—ã—Ç–∞—â–∏–º –≤—Å–µ "..." –∏–ª–∏ '...'
        quoted = re.findall(r'"([^"]+)"|\'([^\']+)\'', s)
        if quoted:
            extracted = []
            for a, b in quoted:
                t = (a or b or "").strip()
                if t:
                    extracted.append(t)
            phrases = extracted
        else:
            # –¥–µ–ª–∏–º –ø–æ –ø–µ—Ä–µ–≤–æ–¥–∞–º —Å—Ç—Ä–æ–∫ / —Ç–æ—á–∫–∞–º —Å –∑–∞–ø—è—Ç–æ–π
            if "\n" in s:
                parts = [x.strip(" -‚Ä¢\t").strip() for x in s.splitlines() if x.strip()]
                phrases = parts
            elif ";" in s:
                phrases = [x.strip() for x in s.split(";") if x.strip()]
            else:
                # –¥–µ–ª–∏–º –ø–æ –∑–∞–ø—è—Ç—ã–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ (–µ—Å—Ç—å 2+ –∑–∞–ø—è—Ç—ã—Ö)
                if s.count(",") >= 2:
                    phrases = [x.strip() for x in s.split(",") if x.strip()]
                else:
                    phrases = [s] if s else []

    # –§–∏–Ω–∞–ª—å–Ω–∞—è —á–∏—Å—Ç–∫–∞
    if not isinstance(phrases, list):
        return []

    cleaned = []
    for p in phrases:
        if not isinstance(p, str):
            continue
        t = p.strip()
        if not t:
            continue
        # —É–±–∏—Ä–∞–µ–º –æ–±—Ä–∞–º–ª—è—é—â–∏–µ –∫–∞–≤—ã—á–∫–∏
        t = t.strip('"')

        # –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ä–µ–∂–µ–º (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ "–ø–æ–ª–æ—Ç–Ω–∞" –≤ –∫–Ω–æ–ø–∫–µ)
        if len(t) > 80:
            t = t[:77] + "‚Ä¶"
        cleaned.append(t)

    # —É–Ω–∏–∫–∞–ª–∏–∑–∏—Ä—É–µ–º, –º–∞–∫—Å–∏–º—É–º 4
    uniq = []
    seen = set()
    for t in cleaned:
        key = t.lower()
        if key in seen:
            continue
        seen.add(key)
        uniq.append(t)
        if len(uniq) >= 4:
            break

    return uniq


def build_suggestions_inline(
    phrases: list[str], message_id: int
) -> InlineKeyboardMarkup:
    keyboard = []

    for idx, phrase in enumerate(phrases[:4]):  # –º–∞–∫—Å–∏–º—É–º 4 –∫–Ω–æ–ø–∫–∏
        keyboard.append(
            [
                InlineKeyboardButton(
                    text=phrase, callback_data=f"sugg:{message_id}:{idx}"
                )
            ]
        )

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def extract_english_for_tts(text: str) -> str:
    """
    –û—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è TTS —Ç–æ–ª—å–∫–æ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã –∏ –±–∞–∑–æ–≤—É—é –ø—É–Ω–∫—Ç—É–∞—Ü–∏—é.
    –£–±–∏—Ä–∞–µ–º –∫–∏—Ä–∏–ª–ª–∏—Ü—É, —á—Ç–æ–±—ã Coqui –Ω–µ —á–∏—Ç–∞–ª —Ä—É—Å—Å–∫–∏–µ —Å–ª–æ–≤–∞ –ø–æ –±—É–∫–≤–∞–º.
    """
    if not text:
        return ""

    allowed = set(
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?;:'\"-()[]\n"
    )
    filtered = "".join(ch for ch in text if ch in allowed)

    # –£–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏/–¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
    lines = [ln.strip() for ln in filtered.splitlines() if ln.strip()]
    result = "\n".join(lines)
    while "  " in result:
        result = result.replace("  ", " ")
    return result.strip()


async def process_user_message(message: Message, user_text: str):
    user_id = message.from_user.id
    username = message.from_user.username

    bot = message.bot

    history = get_conversation_history(user_id)
    await bot.send_chat_action(user_id, ChatAction.TYPING)
    await asyncio.sleep(random.uniform(1.5, 3.0))

    # --- user level (must exist in all branches) ---
    user_level = "A1"
    user = get_user(user_id)
    if user and len(user) > 4 and user[4]:
        user_level = user[4]

    bot_response = get_ollama_response(user_text, history, level=user_level or "A1")
    # –£–±–∏—Ä–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ –º–µ—Ç–∫–∏, —á—Ç–æ–±—ã –æ—Ç–≤–µ—Ç—ã –≤—ã–≥–ª—è–¥–µ–ª–∏ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ
    bot_response = re.sub(r"(?mi)^\s*Correct:\s*", "", bot_response)
    bot_response = re.sub(r"(?mi)^\s*Tip:\s*", "", bot_response)
    bot_response = re.sub(r"\n{3,}", "\n\n", bot_response).strip()

    clean_text = bot_response.replace("Question:", "").strip()

    save_message(user_id, "user", user_text)
    save_message(user_id, "assistant", bot_response)
    increment_message_count(user_id, username)

    # STREAK
    user_data = user  # –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ, —á—Ç–æ —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ –≤—ã—à–µ
    if user_data and len(user_data) >= 8:
        last_active = user_data[6]
        current_streak = user_data[7] or 0
        today = date.today()
        today_str = today.isoformat()
        if last_active == today_str:
            new_streak = current_streak
        elif last_active == (today - timedelta(days=1)).isoformat():
            new_streak = current_streak + 1
        else:
            new_streak = 1
        update_user_streak(user_id, new_streak, today_str)

    # –û—Ç–≤–µ—Ç
    if "---" in bot_response:
        english_part = bot_response.split("---", 1)[0].strip()
        full_text = clean_text
    else:
        english_part = bot_response
        full_text = clean_text

    await asyncio.sleep(random.uniform(0.5, 1.0))
    await bot.send_chat_action(user_id, ChatAction.RECORD_VOICE)
    try:
        await asyncio.sleep(random.uniform(2.0, 4.0))
        tts_text = extract_english_for_tts(english_part)
        audio_path = text_to_speech(tts_text)

        if audio_path:
            audio_file = FSInputFile(audio_path)
            await message.answer_voice(audio_file)
            await asyncio.sleep(0.5)
            await message.answer(
                full_text, reply_markup=get_main_menu(user_id, username)
            )
            try:
                os.remove(audio_path)
            except:
                pass
        else:
            await message.answer(
                full_text, reply_markup=get_main_menu(user_id, username)
            )
    except Exception as e:
        logger.error(f"Error generating voice: {e}", exc_info=True)
        await message.answer(full_text, reply_markup=get_main_menu(user_id, username))

    # –°—Ç–∞—Ç—É—Å
    # –°—Ç–∞—Ç—É—Å (–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –ª–∏–º–∏—Ç–µ) ‚Äî —Å —É—á–µ—Ç–æ–º –±–æ–Ω—É—Å–∞
    if not (username and username in WHITELIST_USERNAMES) and user_data:

        # Premium ‚Äî –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
        if has_active_subscription(user_id):
            pass
        else:
            FREE_LIMIT = int(os.getenv("FREE_MESSAGE_LIMIT", "25"))
            used = int(user_get(user_data, "message_count", 0))
            bonus = int(user_get(user_data, "messages_count", 0))
            total = FREE_LIMIT + max(bonus, 0)

            messages_left = total - used
            if 0 < messages_left <= 5:
                await message.answer(
                    f"You have {messages_left} free messages left.\n"
                    f"Press button below to get unlimited access!",
                    reply_markup=get_main_menu(user_id, username),
                )

    # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –¥–ª—è A1‚ÄìA2 (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å –æ—Ç –±–æ—Ç–∞)
    user_level = user_data[4] if user_data and len(user_data) > 4 else None
    if user_level in ["A1", "A2"]:
        question = extract_question_for_suggestions(bot_response)

        # –µ—Å–ª–∏ –≤–æ–ø—Ä–æ—Å–∞ –Ω–µ—Ç ‚Äî –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É (—á—Ç–æ–±—ã –Ω–µ —Ä–∞–∑–¥—Ä–∞–∂–∞–ª–∞)
        if question:
            phrases = []
            try:
                # –ü—ã—Ç–∞–µ–º—Å—è –≤—ã–∑–≤–∞—Ç—å —Å –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ (–µ—Å–ª–∏ —Ç–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è)
                phrases = get_dynamic_suggestions(question=question, level=user_level)
            except TypeError:
                # –§–æ–ª–±—ç–∫: –µ—Å–ª–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –¥—Ä—É–≥–∞—è
                try:
                    phrases = get_dynamic_suggestions(question, user_level)
                except TypeError:
                    phrases = get_dynamic_suggestions(question)

            # –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥—Å–∫–∞–∑–æ–∫
            phrases = normalize_suggestion_phrases(phrases)

            if phrases:
                # –ö–µ—à–∏—Ä—É–µ–º –ø–æ message_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è,
                # —á—Ç–æ–±—ã callback —Ç–æ—á–Ω–æ –º–æ–≥ –Ω–∞–π—Ç–∏ –Ω—É–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
                SUGGESTIONS_CACHE[message.message_id] = {
                    str(i): phrases[i] for i in range(min(4, len(phrases)))
                }

                await message.reply(
                    "üí° Quick replies:",
                    reply_markup=build_suggestions_inline(phrases, message.message_id),
                )

    # Streak —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ

    if "last_active" in locals() and last_active != today_str:
        days = new_streak
        if days % 10 == 1 and days % 100 != 11:
            word = "–¥–µ–Ω—å"
        elif 2 <= days % 10 <= 4 and not (12 <= days % 100 <= 14):
            word = "–¥–Ω—è"
        else:
            word = "–¥–Ω–µ–π"
        await message.answer(
            f"üéØ –¢–≤–æ–π streak: {days} {word} –ø–æ–¥—Ä—è–¥!\n"
            f"–ü—Ä–æ–¥–æ–ª–∂–∞–π –ø—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å—Å—è –∫–∞–∂–¥—ã–π –¥–µ–Ω—å!"
        )


@router.callback_query(F.data.startswith("phrase_"))
async def handle_phrase_selection(callback: CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –≥–æ—Ç–æ–≤–æ–π —Ñ—Ä–∞–∑—ã"""
    await callback.answer()
    phrase_map = {
        "phrase_hello": "Hello!",
        "phrase_how_are_you": "How are you?",
        "phrase_fine_thank_you": "I am fine, thank you",
        "phrase_name": "What is your name?",
        "phrase_goodbye": "Goodbye!",
    }
    selected_phrase = phrase_map.get(callback.data)
    if selected_phrase:
        # –ò–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        user_id = callback.from_user.id
        username = callback.from_user.username
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º "–ø–µ—á–∞—Ç–∞–µ—Ç..."
        await callback.message.bot.send_chat_action(user_id, ChatAction.TYPING)
        # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        await asyncio.sleep(random.uniform(1.5, 3.0))
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await process_user_message(callback.message, selected_phrase)


@router.message(F.voice)
async def handle_voice_message(message: Message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ì–û–õ–û–°–û–í–´–• —Å–æ–æ–±—â–µ–Ω–∏–π"""
    user_id = message.from_user.id
    username = message.from_user.username

    # Rate limiting
    current_time = time()
    last_time = _last_message_time.get(user_id, 0)
    if current_time - last_time < RATE_LIMIT_SECONDS:
        await message.answer(
            f"‚è≥ Please wait {RATE_LIMIT_SECONDS} seconds between messages."
        )
        return
    _last_message_time[user_id] = current_time

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º/—Å–æ–∑–¥–∞—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = get_user(user_id)
    if user and len(user) > 4 and user[4]:
        user_level = user[4]

    if not user:
        create_user(user_id, username or message.from_user.first_name)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–Ω–±–æ—Ä–¥–∏–Ω–≥
    if not is_onboarding_completed(user_id):
        await message.answer(
            "Please complete the onboarding first! Use /start to begin.",
            reply_markup=get_main_menu(user_id, username),
        )
        return

    # –ü–†–û–í–ï–†–Ø–ï–ú –õ–ò–ú–ò–¢–´ –° USERNAME
    if not can_send_message(user_id, username):
        await message.answer(
            "You've used all your free messages!\n"
            "Get a subscription to continue practicing English\n"
            "Press button below to see prices!",
            reply_markup=get_main_menu(user_id, username),
        )
        return

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º "–ø–µ—á–∞—Ç–∞–µ—Ç..." –ø–æ–∫–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
    await message.bot.send_chat_action(user_id, ChatAction.TYPING)
    try:
        voice = message.voice
        file = await message.bot.get_file(voice.file_id)
        # –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        with tempfile.NamedTemporaryFile(delete=False, suffix=".ogg") as temp_file:
            temp_path = temp_file.name
            await message.bot.download_file(file.file_path, temp_path)
        # –†–∞—Å–ø–æ–∑–Ω–∞—ë–º —Ä–µ—á—å —á–µ—Ä–µ–∑ Whisper
        user_text = transcribe_audio(temp_path)
        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        try:
            os.remove(temp_path)
        except:
            pass
        if not user_text:
            await message.answer(
                "Sorry, I couldn't understand that. Could you try again?\n"
                "Make sure you're speaking clearly in English.",
                reply_markup=get_main_menu(user_id, username),
            )
            return
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —á—Ç–æ —É—Å–ª—ã—à–∞–ª–∏
        await message.answer(f'You said: "{user_text}"')
        # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
        await asyncio.sleep(random.uniform(0.5, 1.0))
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        await process_user_message(message, user_text)
    except Exception as e:
        print(f"Error processing voice: {e}")
        import traceback

        traceback.print_exc()
        await message.answer(
            "Sorry, there was an error processing your voice message. "
            "Please try again or send a text message.",
            reply_markup=get_main_menu(user_id, username),
        )


@router.message(F.text)
async def handle_text_message(message: Message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¢–ï–ö–°–¢–ù–´–• —Å–æ–æ–±—â–µ–Ω–∏–π"""
    user_id = message.from_user.id
    username = message.from_user.username
    user_text = message.text

    # Rate limiting
    current_time = time()
    last_time = _last_message_time.get(user_id, 0)
    if current_time - last_time < RATE_LIMIT_SECONDS:
        await message.answer(
            f"‚è≥ Please wait {RATE_LIMIT_SECONDS} seconds between messages."
        )
        return
    _last_message_time[user_id] = current_time

    print(f"\nüì® === –ü–û–õ–£–ß–ï–ù–û –°–û–û–ë–©–ï–ù–ò–ï ===")
    print(f"User ID: {user_id}")
    print(f"Username: {username}")
    print(f"–¢–µ–∫—Å—Ç: {user_text}")

    # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã –∏ –∫–Ω–æ–ø–∫–∏
    if user_text.startswith("/") or user_text in [
        "üìä –ú–æ–π —Å—Ç–∞—Ç—É—Å",
        "üíé –ö—É–ø–∏—Ç—å Premium",
        "üíé –ü—Ä–æ–¥–ª–∏—Ç—å Premium",
        "üß† –û—á–∏—Å—Ç–∏—Ç—å –ø–∞–º—è—Ç—å",
        "‚ùì –ü–æ–º–æ—â—å",
        "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
    ]:
        print("–≠—Ç–æ –∫–æ–º–∞–Ω–¥–∞ –∏–ª–∏ –∫–Ω–æ–ø–∫–∞ - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º/—Å–æ–∑–¥–∞—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    print(f"–ü—Ä–æ–≤–µ—Ä—è—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ...")
    user = get_user(user_id)
    if not user:
        print(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω! –°–æ–∑–¥–∞—é...")
        create_user(user_id, username or message.from_user.first_name)
        user = get_user(user_id)
        print(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞–Ω: {user}")
    else:
        print(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω: {user}")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–Ω–±–æ—Ä–¥–∏–Ω–≥
    if not is_onboarding_completed(user_id):
        await message.answer(
            "Please complete the onboarding first! Use /start to begin.",
            reply_markup=get_main_menu(user_id, username),
        )
        return

    # –ü–†–û–í–ï–†–Ø–ï–ú –õ–ò–ú–ò–¢–´ –° USERNAME
    print(f"–ü—Ä–æ–≤–µ—Ä—è—é –ª–∏–º–∏—Ç—ã...")
    can_send = can_send_message(user_id, username)
    print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç can_send_message: {can_send}")
    if not can_send:
        print(f"–õ–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω!")
        await message.answer(
            "You've used all your free messages!\n"
            "Get a subscription to continue practicing English\n"
            "Press button below to see prices!",
            reply_markup=get_main_menu(user_id, username),
        )
        return

    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    await process_user_message(message, user_text)


@router.callback_query(F.data.startswith("sugg:"))
async def on_suggestion_click(callback: CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ inline-–ø–æ–¥—Å–∫–∞–∑–∫—É"""
    await callback.answer()

    try:
        _, mid_str, idx = callback.data.split(":", 2)
        mid = int(mid_str)
    except Exception:
        await callback.answer("Outdated button. Send a message again.")
        return

    mapping = SUGGESTIONS_CACHE.get(mid, {})
    text = mapping.get(idx, "")

    if not text:
        await callback.answer("Outdated button. Send a message again.")
        return

    # —É–±–∏—Ä–∞–µ–º –∫–Ω–æ–ø–∫–∏, —á—Ç–æ–±—ã –Ω–µ —Ç—ã–∫–∞–ª–∏ 100 —Ä–∞–∑
    try:
        await callback.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass

    # –æ—á–∏—â–∞–µ–º –∫–µ—à –¥–ª—è —ç—Ç–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    SUGGESTIONS_CACHE.pop(mid, None)

    # –¥–∞–ª—å—à–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
    await process_user_message(callback.message, text)
